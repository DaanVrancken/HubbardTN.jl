var documenterSearchIndex = {"docs":
[{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This page demonstrates how to use HubbardTN to build and solve different 1D Hubbard models using tensor networks.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Two examples are provided:","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"A minimal single-band Hubbard model\nA general multi-band Hubbard model","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"Examples/#Minimal-Example","page":"Examples","title":"üß© Minimal Example","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using HubbardTN\nusing TensorKit\n\n# Step 1: Define the symmetries\nparticle_symmetry = U1Irrep\nspin_symmetry = U1Irrep\ncell_width = 2\nfilling = (1, 1)\n\nsymm = SymmetryConfig(particle_symmetry, spin_symmetry, cell_width, filling)\n\n# Step 2: Set up model parameters\nt = [0.0, 1.0]   # [chemical_potential, nn_hopping, nnn_hopping, ...]\nU = [4.0]        # [on-site interaction, nn_interaction, ...]\n\nmodel = ModelParams(t, U)\ncalc = CalcConfig(symm, model)\n\n# Step 3: Compute the ground state\ngs = compute_groundstate(calc)\nœà = gs[\"groundstate\"]\nH = gs[\"ham\"]\n\nprintln(\"Ground-state energy density: \", expectation_value(œà, H) / length(H))\n\n# Step 4: Compute first excitation in fZ2(0) √ó U1Irrep(0) √ó U1Irrep(0) sector\nmomenta = collect(range(0, 2œÄ, length = 10))\ncharges = [0.0, 0.0, 0.0]\nex = compute_excitations(gs, momenta, charges)","category":"page"},{"location":"Examples/#Notes","page":"Examples","title":"Notes","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The SymmetryConfig object defines all symmetry information of the model:\nThe particle and spin symmetries (Trivial, U1Irrep, or SU2Irrep)\nThe number of sites in the unit cell (cell_width)\nThe filling fraction, defined by N_electrons / N_sites via the keyword filling=(N_electrons, N_sites)\nThe ModelParams constructor shown above is the simplest form, suitable for single-band Hubbard models.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"Examples/#General-Multi-Band-Model","page":"Examples","title":"‚öôÔ∏è General Multi-Band Model","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The example below illustrates a two-band Hubbard model with custom hopping and interaction terms.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using HubbardTN\nusing TensorKit\n\n# Step 1: Define the symmetries\nparticle_symmetry = U1Irrep\nspin_symmetry = SU2Irrep\ncell_width = 2\nfilling = (1, 1)\n\nsymm = SymmetryConfig(particle_symmetry, spin_symmetry, cell_width, filling)\n\n# Step 2: Define model parameters\nbands = 2\n\n# Hopping amplitudes:\n# (1,2) and (2,1): inter-band hopping\n# (2,3) and (3,2): next-nearest-neighbor hopping across unit cells\nt = Dict((1,2)=>1.0, (2,1)=>1.0, (2,3)=>0.5, (3,2)=>0.5)\n\n# Interaction terms:\n# (i,j,k,l) correspond to U_ijkl c‚Å∫_i c‚Å∫_j c_k c_l\nU = Dict(\n    (1,1,1,1) => 8.0,   # on-site band 1\n    (2,2,2,2) => 8.0,   # on-site band 2\n    (1,2,1,2) => 1.0,   # inter-orbital exchange\n    (2,1,2,1) => 1.0\n)\n\nmodel = ModelParams(bands, t, U)\ncalc = CalcConfig(symm, model)\n\n# Step 3: Compute the ground state\ngs = compute_groundstate(calc)\nœà = gs[\"groundstate\"]\nH = gs[\"ham\"]\n\nprintln(\"Ground-state energy density: \", expectation_value(œà, H) / length(H))\n\n# Step 4: Compute first excitations\nmomenta = collect(range(0, 2œÄ, length = 10))\ncharges = [0.0, 0.0, 0.0]\nex = compute_excitations(gs, momenta, charges)","category":"page"},{"location":"Examples/#Notes-2","page":"Examples","title":"Notes","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Dictionaries are used to define hopping (t) and interaction (U) parameters:\nKeys represent index tuples:\n(i, j) for hopping ‚Üí corresponds to c‚Å∫·µ¢ c‚±º\n(i, j, k, l) for interactions ‚Üí corresponds to c‚Å∫·µ¢ c‚Å∫‚±º c‚Çñ c‚Çó\nIndices larger than the number of bands refer to orbitals in neighboring unit cells.\nThis flexible formulation allows the user to specify arbitrary band connectivity and interaction structure.\nBeyond the usual on-site interactions, exchange or other couplings can be included naturally.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"üìò Tip:   For advanced use cases (custom operators, constrained symmetry sectors, or DMRG sweep control), see the API reference for   compute_groundstate, compute_excitations, and ModelParams.","category":"page"},{"location":"Functions/#Library-documentation","page":"Library","title":"Library documentation","text":"","category":"section"},{"location":"Functions/#HubbardTN.CalcConfig","page":"Library","title":"HubbardTN.CalcConfig","text":"CalcConfig\n\nHolds all configuration information for a lattice calculation, including symmetries and model parameters.\n\nFields\n\nsymmetries::SymmetryConfig     Contains particle and spin symmetries, unit cell width, and optional filling.\nmodel::ModelParams{Float64}     Contains the Hamiltonian parameters: number of bands, hopping amplitudes, and two-body interactions.\n\n\n\n\n\n","category":"type"},{"location":"Functions/#HubbardTN.ModelParams","page":"Library","title":"HubbardTN.ModelParams","text":"ModelParams{T<:AbstractFloat}\n\nRepresents the Hamiltonian parameters for a lattice or multi-orbital system, including hopping terms and two-body interactions.\n\nFields\n\nbands::Int64     Number of orbitals or bands per unit cell. Must be positive.\nt::Dict{NTuple{2, Int64}, T}     Hopping amplitudes between sites. Convention: t[(i,i)] = Œº_i is the on-site potential,   t[(i,j)] for i ‚â† j is the hopping amplitude from site i to j.\nU::Dict{NTuple{4, Int64}, T}     Two-body interaction tensor. Entries U[(i,j,k,l)] correspond to the operator   c‚Å∫i c‚Å∫j ck cl. Zero entries can be omitted from the dictionary.\nA::Dict{NTuple{6, Int64}, T}     Placeholder for three-body interactions (Not yet implemented).\n\nConstructors\n\nModelParams{T}(bands::Int64, t::Dict{NTuple{2, Int64}, T}, U::Dict{NTuple{4,Int},T})   Standard constructor with explicit number of bands, hopping dictionary, and interaction dictionary.\nModelParams(t::Vector{T}, U::Dict{NTuple{4,Int},T})   Single-band constructor using hopping vector and two-body interaction dictionary.\nModelParams(t::Vector{T}, U::Vector{T})   Single-band constructor from hopping vector and a vector of on-site interactions. Automatically converts vectors into the interaction dictionary.\nModelParams(t::Vector{T}, U::Vector{T}, exchange::Vector{T}, pair_hop::Vector{T}=exchange, bond_charge::Vector{T}=[0.0])   Constructs interactions including density-density (U), exchange, pair-hopping, and bond-charge terms.\nModelParams(t::Matrix{T}, U::Matrix{T})   Multi-band constructor from hopping matrix and two-body interaction matrix. Checks Hermiticity and correct dimensions.\nModelParams(t::Vector{T}, U::Vector{T}, exchange::Vector{T}, pair_hop::Vector{T}=exchange)   Multi-band constructor with vectors of interactions, converted into the internal dictionary.\n\nNotes\n\nThe constructors automatically convert hopping and interaction data from arrays or vectors into the internal Dict representation.\nHermiticity of on-site interaction matrices is asserted where applicable.\nInteraction dictionaries are structured for use in constructing many-body Hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"Functions/#HubbardTN.SymmetryConfig","page":"Library","title":"HubbardTN.SymmetryConfig","text":"SymmetryConfig(particle_symmetry, spin_symmetry; cell_width=1, filling=nothing)\n\nRepresents the symmetry configuration of a lattice system, including particle and spin symmetries, unit cell width, and optional filling information.\n\nFields\n\nparticle_symmetry : Union{Type{Trivial}, Type{U1Irrep}, Type{SU2Irrep}}\nThe symmetry type for particle number. Use Trivial for no symmetry, U1Irrep for U(1) symmetry, or SU2Irrep for SU(2) symmetry.\nspin_symmetry : Union{Type{Trivial}, Type{U1Irrep}, Type{SU2Irrep}}\nThe symmetry type for spin degrees of freedom.\ncell_width : Int64\nNumber of sites in the unit cell. Must be a positive integer. Defaults to 1.\nfilling : Union{Nothing, Tuple{Int64, Int64}}\nOptional particle filling specified as a fraction (numerator, denominator). Only allowed if particle_symmetry is U1Irrep. \nOtherwise the filling is determined by the chemical potential.\n\nConstructor Behavior\n\nIf filling is provided, the constructor checks that particle_symmetry == U1Irrep.\ncell_width must be positive.\nIf particle_symmetry is U1Irrep and filling is specified, the constructor ensures that cell_width is a multiple of filling[2] * (mod(filling[1], 2) + 1) to accommodate the specified filling.\n\nExamples\n\n```julia\n\nTrivial particle and spin symmetry, default cell width\n\ncfg1 = SymmetryConfig(Trivial, Trivial)\n\nU(1) particle symmetry with SU(2) spin symmetry, cell width 2, filling 1/2\n\ncfg2 = SymmetryConfig(U1Irrep, SU2Irrep, cell_width=2, filling=(1,2))\n\n\n\n\n\n","category":"type"},{"location":"Functions/#HubbardTN.c_minplus-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.c_minplus","text":"c_minplus(T, particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the two-body operator that annihilates a particle at the first site and creates a particle at the second. This is the sum of c_minplus_up and c_minplus_down.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.c_minplus_down-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.c_minplus_down","text":"c_minplus_down(T, particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the Hermitian conjugate of c_plusmin_down, i.e. (c_1 c_2) = -c_1 c_2 (note the extra minus sign).  It annihilates a spin-down electron at the first site and creates a spin-down electron at the second.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.c_minplus_up-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.c_minplus_up","text":"c_minplus_up(T, particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the Hermitian conjugate of c_plusmin_up, i.e. (c_1 c_2) = -c_1 c_2 (note the extra minus sign).  It annihilates a spin-up electron at the first site and creates a spin-up electron at the second.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.c_plusmin-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.c_plusmin","text":"c_plusmin(T, particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the two-body operator that creates a particle at the first site and annihilates a particle at the second. This is the sum of c_plusmin_up and c_plusmin_down.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.c_plusmin_down-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.c_plusmin_down","text":"c_plusmin_down(T, particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the two-body operator c_1 c_2 that creates a spin-down electron at the first site and annihilates a spin-down electron at the second.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.c_plusmin_up-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.c_plusmin_up","text":"c_plusmin_up(T, particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the two-body operator c_1 c_2 that creates a spin-up electron at the first site and annihilates a spin-up electron at the second.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.calc_ms-Tuple{MPSKit.InfiniteMPS, SymmetryConfig}","page":"Library","title":"HubbardTN.calc_ms","text":"calc_ms(œà::InfiniteMPS, symm::SymmetryConfig)\n\nCompute the staggered magnetization in an InfiniteMPS.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.compute_domainwall-Tuple{Dict{String, Any}, Union{Float64, Vector{Float64}}, Vector{Float64}}","page":"Library","title":"HubbardTN.compute_domainwall","text":"compute_domainwall(groundstate_dict, momenta, charges; nums=1, shift=1, solver=Arnoldi(...))\n\nCompute domain-wall excitations between a ground state and a spatially shifted version of itself.\n\nArguments\n\ngroundstate_dict::Dict{String,Any}: A dictionary produced by compute_groundstate, containing \"groundstate\", \"ham\", and \"environments\".\nmomenta::Union{Float64,Vector{Float64}}: A collection of momentum values (in units of lattice sites) at which domain-wall excitations are evaluated.\ncharges::Vector{Float64}: Target quantum numbers defining the excitation sector (one value per symmetry).\nnums::Int64=1: Number of excitations to compute per momentum.\nshift::Int64=1: The number of lattice sites by which to shift the reference ground state to form the domain wall.\nsolver: The eigensolver used for diagonalization (default is Arnoldi(; krylovdim=30, tol=1e-6, eager=true)).\n\nReturns\n\nA dictionary with the following keys:\n\n\"Es\": Eigenenergies of the domain-wall excitations.\n\"qps\": Domain-wall quasiparticle ansatz states.\n\"momenta\": The input momentum values.\n\nNotes\n\nThis function constructs the second ‚Äúshifted‚Äù ground state and its environments automatically using circshift and environments.   It then computes excitations between the two MPS states within the specified symmetry sector.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.compute_excitations-Tuple{Dict{String, Any}, Union{Float64, Vector{Float64}}, Union{Vector{Float64}, Vector{Int64}}}","page":"Library","title":"HubbardTN.compute_excitations","text":"compute_excitations(groundstate_dict, momenta, charges; nums=1, solver=Arnoldi(...))\n\nCompute the low-lying quasiparticle excitations above a given ground state.\n\nArguments\n\ngroundstate_dict::Dict{String,Any}: A dictionary produced by compute_groundstate, containing the keys \"groundstate\", \"ham\", and \"environments\".\nmomenta::Union{Float64,Vector{Float64}}: A collection of momentum values (in units of lattice sites) at which excitations are evaluated.\ncharges::Vector{Float64}: Target quantum numbers defining the excitation sector (one value per symmetry).\nnums::Int64=1: Number of excitations to compute per momentum.\nsolver: The eigensolver used for diagonalization (default is Arnoldi(; krylovdim=30, tol=1e-6, eager=true)).\n\nReturns\n\nA dictionary with the following keys:\n\n\"Es\": Eigenenergies of the excitations.\n\"qps\": Quasiparticle ansatz states.\n\"momenta\": The input momentum values.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.compute_groundstate-Tuple{CalcConfig}","page":"Library","title":"HubbardTN.compute_groundstate","text":"compute_groundstate(calc::CalcConfig;\n                    svalue::Float64=2.0,\n                    tol::Float64=1e-8,\n                    init_state::Union{Nothing, InfiniteMPS}=nothing,\n                    maxiter::Int=1000,\n                    max_init_dim::Int=50,\n                    verbosity::Int=0)\n\nCompute the ground state of the Hamiltonian defined by the CalcConfig calc.\n\nKeyword Arguments\n\nsvalue::Float64=2.0:    Exponent used to define the truncation cutoff as 10^(-svalue) for Schmidt value truncation.\ntol::Float64=1e-8:    Convergence tolerance for iterative solvers (used by VUMPS or IDMRG2).\ninit_state::Union{Nothing, InfiniteMPS}=nothing:    Optional initial infinite MPS. If not provided, a random symmetry-consistent MPS.\nmaxiter::Int=1000:    Maximum number of iterations for ground state optimization.\nmax_init_dim::Int=50:    Maximum bond dimension for the initial MPS construction.\nverbosity::Int=0:    Controls the level of printed output from the solver.\n\nReturns\n\nA Dict with the following entries:\n\n\"groundstate\" ‚Üí optimized infinite MPS representing the ground state.\n\"environments\" ‚Üí left and right environment tensors.\n\"ham\" ‚Üí Hamiltonian MPO used in the optimization.\n\"error\" ‚Üí final convergence error.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.density_e-Tuple{MPSKit.InfiniteMPS, SymmetryConfig}","page":"Library","title":"HubbardTN.density_e","text":"density_e(œà::InfiniteMPS, symm::SymmetryConfig)\n\nCompute the number of electrons per site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.density_spin-Tuple{MPSKit.InfiniteMPS, SymmetryConfig}","page":"Library","title":"HubbardTN.density_spin","text":"density_spin(œà::InfiniteMPS, symm::SymmetryConfig)\n\nCompute the spin density per site in the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.dim_state-Tuple{MPSKit.InfiniteMPS}","page":"Library","title":"HubbardTN.dim_state","text":"dim_state(œà::InfiniteMPS)\n\nDetermine the bond dimensions in an infinite MPS.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.find_chemical_potential-Tuple{CalcConfig}","page":"Library","title":"HubbardTN.find_chemical_potential","text":"find_chemical_potential(calc::CalcConfig;\n                        svalue::Float64=2.0,\n                        tol::Float64=1e-8,\n                        init_state::Union{Nothing, InfiniteMPS}=nothing,\n                        maxiter::Int=1000,\n                        max_init_dim::Int=50,\n                        verbosity::Int=0)\n\nFind the chemical potential Œº that yields the desired filling in the ground state.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.hamiltonian-Tuple{CalcConfig}","page":"Library","title":"HubbardTN.hamiltonian","text":"hamiltonian(calc::CalcConfig)\n\nConstructs the many-body Hamiltonian for a lattice system with given hopping  and interaction parameters, taking into account particle and spin symmetries.\n\nArguments\n\ncalc::CalcConfig : A configuration object containing:\ncalc.symmetries : SymmetryConfig, which includes:\nparticle_symmetry  - type of particle symmetry\nspin_symmetry      - type of spin symmetry\ncell_width         - number of unit cells in the system\nfilling            - particle filling\ncalc.model : Model parameters, which include:\nbands - number of orbitals per unit cell\nt     - hopping matrix or list of hopping terms\nU     - two-body interaction tensor\n\nReturns\n\nH : The Hamiltonian as an Matrix Product Operator.\n\nNotes\n\nLattice sites are represented using an InfiniteChain of length cell_width * bands.\nThe resulting MPO can be used directly for DMRG, VUMPS, or other tensor network calculations.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.hubbard_space","page":"Library","title":"HubbardTN.hubbard_space","text":"hubbard_space(particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector}; (P,Q)::Tuple{Int64, Int64}=(1,1))\n\nReturn the local hilbert space for a Hubbard-type model with the given particle and spin symmetries. The possible symmetries are Trivial, U1Irrep, and SU2Irrep, for both particle number and spin. When using U1Irrep particle symmetry, the filling can be adjusted to P particles per Q sites by passing the keyword filling=(P,Q). The default is (1,1), i.e., half-filling.\n\n\n\n\n\n","category":"function"},{"location":"Functions/#HubbardTN.load_computation-Tuple{String}","page":"Library","title":"HubbardTN.load_computation","text":"load_computation(path_to_file::String)\n\nLoad the output dictionary of e.g. compute_groundstate stored as a .jld2 file.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.load_state-Tuple{String}","page":"Library","title":"HubbardTN.load_state","text":"load_state(path::String) -> InfiniteMPS\n\nLoad an InfiniteMPS object from a directory of saved .jld2 tensor files.\n\nArguments\n\npath::String: Path to the directory containing the saved MPS tensor files  (e.g., state1.jld2, state2.jld2, ...).\n\nDescription\n\nThis function reconstructs an InfiniteMPS object previously saved with save_state.   It reads all .jld2 files in the specified directory, converts each stored Dict back into a TensorMap, and combines them into a periodic array before wrapping  the result in an InfiniteMPS object.\n\nReturns\n\nInfiniteMPS: The reconstructed infinite matrix product state.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.number_down-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.number_down","text":"number_down(particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the one-body operator that counts the number of spin-down electrons.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.number_e-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.number_e","text":"number_e(T, particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the one-body operator that counts the number of particles.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.number_pair-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.number_pair","text":"number_pair(T, particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the one-body operator that counts the number of doubly occupied sites.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.number_up-Tuple{Type{<:TensorKitSectors.Sector}, Type{<:TensorKitSectors.Sector}}","page":"Library","title":"HubbardTN.number_up","text":"number_up(particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector})\n\nReturn the one-body operator that counts the number of spin-up electrons.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.save_computation-Tuple{Dict{String, Any}, String, String}","page":"Library","title":"HubbardTN.save_computation","text":"save_computation(d::Dict{String, Any}, path::String, file_name::String)\n\nSave the output dictionary of e.g. compute_groundstate as a .jld2 file at the specified path.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.save_state-Tuple{MPSKit.InfiniteMPS, String, String}","page":"Library","title":"HubbardTN.save_state","text":"save_state(œà::InfiniteMPS, path::String, name::String)\n\nSave the tensors of an InfiniteMPS object to disk as individual .jld2 files.\n\nArguments\n\nœà::InfiniteMPS: The infinite matrix product state (MPS) whose tensors will be saved.\npath::String: The base directory where the state folder will be created.\nname::String: The name of the subdirectory under path where the tensors will be stored.\n\nDescription\n\nThis function creates a subdirectory joinpath(path, name) and saves each tensor  œà.AL[i] as a .jld2 file named state<i>.jld2 inside it. Each tensor is converted  to a Dict before saving for serialization compatibility. The function prints  a message after each tensor is successfully saved. This approach may be useful for storing large MPS objects.\n\n\n\n\n\n","category":"method"},{"location":"#HubbardTN","page":"Home","title":"HubbardTN","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for HubbardTN, a Julia package for constructing and solving general 1D multi-band Hubbard models using tensor network techniques.   The framework builds on top of MPSKit.jl and TensorKit.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install HubbardTN directly from its GitHub repository:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/DaanVrancken/HubbardTN.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"After installation, load the package with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using HubbardTN","category":"page"},{"location":"#Usage-Overview","page":"Home","title":"Usage Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A typical HubbardTN simulation follows a clear sequence of steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define the symmetries.   Every model includes a built-in fermionic ‚Ñ§‚ÇÇ symmetry.   For the particle and spin symmetries, you can choose among:\nTrivial\nU1Irrep\nSU2Irrep  \nThese are specified in a SymmetryConfig object.\nSpecify the model parameters.   Insert your model‚Äôs coupling constants and hopping terms into a ModelParams object.   This defines the Hamiltonian that will be constructed.\nCompute physical quantities.   With the symmetry and model defined, you can:\nCompute the ground state using compute_groundstate.\nObtain excitations with compute_excitations.\nInvestigate domain walls via compute_domainwall.","category":"page"}]
}
