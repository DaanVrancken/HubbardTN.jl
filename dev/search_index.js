var documenterSearchIndex = {"docs":
[{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Several examples can be found in the \"examples\" folder of the repository. In this tutorial, we elaborate on some of the details.","category":"page"},{"location":"Examples/#Initialization","page":"Examples","title":"Initialization","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"To make use of the functionalities, we first need to import the package","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"julia> using HubbardTN","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"We also define a directory where we want to store our output data","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"julia> path = \"output\"","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"This will allow us to load previously calculated states at a later time or compute excited states without having to recompute the ground state, for example.","category":"page"},{"location":"Examples/#One-band","page":"Examples","title":"One-band","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Each Hubbard model is linked to a structure, storing all its major properties. The first question we ask ourselves is whether we want to conserve the number of electrons by imposing a U(1) symmetry, or if we want to add a chemical potential to deal with this. The first we achieve by using the OB_Sim() structure, the latter with OBC_Sim().","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The most important properties of OB_Sim() are the hoppig t, the Hubbard u, the chemical potential µ, and the filling defined by the ratio P/Q.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"s = 2.5             # Schmidt cut value, determines bond dimension.\nP = 1;              # Filling of P/Q. P/Q = 1 is half-filling.\nQ = 1;\nbond_dim = 20;      # Initial bond dimension of the state. Impact on result is small as DMRG modifies it.\n\n# Define hopping, direct interaction, and chemical potential.\nt=[1.0, 0.1];\nu=[8.0];\nμ=0.0;\n\n# Spin=false will use SU(2) spin symmetry, the exact spin configuration cannot be deduced.\nSpin = false\n\nmodel = OB_Sim(t, u, μ, P, Q, s, bond_dim; spin=Spin);","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"t is a vector where the first element is the nearest neighbour hopping, the second the next-nearest neighbour hopping, and so on. Similarly, the first element of u is the on-site Coulomb repulsion and the second element the interaction between two neighbouring sites. ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The Schmidt cut s determines to which value the bond dimension is grown by the iDMRG2 algorithm, while bond_dim is the maximal value used for the initialization of the MPS.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"NOTE: In order to preserve injectivity, a unit cell of size Q is used if Pis even and of size 2*Q if P is odd. Therefore, filling ratios that deviate from half filling P=Q=1 tend to be more computationally intensive.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Finally, the tag spin determines if spin up and down have to be treated independently. If spin=false, an additional SU(2) symmetry is imposed, reducing the local Hilbert space dimension to 3 and leading to a substantial speed up. However, no information about the spin of a state can be retrieved.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"OBC_Sim() works similarly. Now, we either provide a chemical potential or a filling.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"model_OBC_1 = OBC_Sim(t, u, P/Q, s, bond_dim; mu=false)\nmodel_OBC_2 = OBC_Sim(t, u, μ, s, bond_dim; mu=true)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"If a filling is defined, the corresponding chemical potential is sought iteratively. Calculations without spin symmetry are not yet implemented.","category":"page"},{"location":"Examples/#Multi-band","page":"Examples","title":"Multi-band","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"In analogy with the one-band model, multi-band models can be constructed using MB_Sim() or MBC_Sim(). For the one-band model, DrWatson.jl is able to find a unique name for the model based on its parameters. This name is later used to retrieve earlier computed results. For multi-band models, the number of parameters is simply too large and we have to provide a unique name ourselves, like the name of the script for instance.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"name_jl = last(splitpath(Base.source_path()))\nname = first(split(name_jl,\".\"))","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Then, we insert the parameters in the form of Btimes B matrices, where B is the number of bands. For a 2-band model this looks as follows","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"s = 2.5             # Schmidt cut value, determines bond dimension.\nP = 1;              # Filling of P/Q. P/Q = 1 is half-filling.\nQ = 1;\nbond_dim = 20;      # Initial bond dimension of the state. Impact on result is small as DMRG modifies it.\n\n# Define hopping, direct and exchange interaction matrices.\nt_onsite = [0.000 3.803; 3.803 0.000];\nt_intersite = [-0.548 0.000;2.977 -0.501];\nt = cat(t_onsite,t_intersite, dims=2);\nU = [10.317 6.264 0.000 0.000; 6.264 10.317 6.162 0.000];\nJ = [0.000 0.123 0.000 0.000; 0.123 0.000 0.113 0.000];\nU13 = zeros(2,2)\n\nmodel = MB_Sim(t, U, J, U13, P, Q, s, bond_dim; code = name);","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Where the one-band model used vectors for t and u, the multi-band model concatenates matrices horizontally. In addition, the exchange J and U_ijjj parameters, with zeros on the diagonals as these are included in u, are implemented as well. Since those parameters are usually rather small, U13 is an optional argument. Furthermore, parameters of the form U_ijkk and U_ijkl can be implemented by providing dictionaries as kwargs tot the structure","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"U112 = Dict((1,1,2,3) => 0.0, (1,2,4,2) => 0.0) # and so on ...\nU1111 = Dict((1,2,3,4) => 0.0, (3,2,4,1) => 0.0) # ...\nmodel = MB_Sim(t, U, J, U13, P, Q, s, bond_dim; code = name, U112=U112, U1111=U1111)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"An index i larger than B corresponds to band i modulo B on site iB.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"For a MBC_Sim() structure, we would have","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"model_MBC = MBC_Sim(t, u, J, s, bond_dim; code=name);","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The chemical potential is included in the diagonal terms of t_onsite. Iterative determination of the chemical potential for a certain filling is not yet supported.","category":"page"},{"location":"Examples/#Ground-state","page":"Examples","title":"Ground state","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"The ground state of a model is computed (or loaded if it has been computed before) by the function produce_groundstate(). We can then extract the ground state energy as the expectation value of the Hamiltonian with respect to the ground state.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"dictionary = produce_groundstate(model; path=path);\nψ₀ = dictionary[\"groundstate\"];\nH = dictionary[\"ham\"];\nE0 = expectation_value(ψ₀, H);\nE = real(E0)./length(H);\nprintln(\"Groundstate energy: $E\")","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Other properties, such as the bond dimension, the electron density and spin density (if it was a calculation without SU(2) symmetry), can be calculated as well.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"println(\"Bond dimension: $(dim_state(ψ₀))\")\nprintln(\"Electron density: $(density_state(ψ₀))\")\nprintln(\"Spin density: $(density_spin(ψ₀))\")","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"NOTE: When the parameters are changed but you want to keep the name of the model the same, you should put force=true to overwrite the previous results, obtained with the old parameters, or store the calculation at a different path. Be cautious for accidentally overwriting data that you want to keep!","category":"page"},{"location":"Examples/#Excited-states","page":"Examples","title":"Excited states","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"To compute quasiparticle excitations we have to choose the momentum, the number of excitations, and the symmetry sectors. ","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"resolution = 5;\nmomenta = range(0, π, resolution);\nnums = 1;\n\nexc = produce_excitations(model, momenta, nums; charges=[0,0.0,0], path=path);\nEs = exc[\"Es\"];\nprintln(\"Excitation energies: \")\nprintln(Es)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Excitations in the same sector as the ground state are found by defining charges as zeros. These charges refer to the difference with the ground state. Be aware that the meaning of the charges in this vector differ depending on the symmetries and thus on the type of model. OBC_Sim and MBC_Sim even have only two symmetries, and hence, two charges.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"For example, a spin symmetric, electron conserving model has symmetry mathbbZ_2times SU(2)times U(1). Sectors obtained by adding a particle or hole differ by charges = [1,1/2,+/-1]. These single-particle excitations allow for the calculation of the band gap.","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"gap, k = produce_bandgap(model; path=path)\nprintln(\"Band Gap for s=$s: $gap eV at momentum $k\")","category":"page"},{"location":"Functions/#Library-documentation","page":"Library","title":"Library documentation","text":"","category":"section"},{"location":"Functions/#HubbardTN.MBC_Sim","page":"Library","title":"HubbardTN.MBC_Sim","text":"MBC_Sim(t::Matrix{Float64}, u::Matrix{Float64}, J::Matrix{Float64}, U13::Matrix{Float64}, svalue=2.0, bond_dim=50; kwargs...)\n\nConstruct a parameter set for a 1D B-band Hubbard model with the number of particles determined by a chemical potential.\n\nArguments\n\nt: Btimes nB matrix in which element (ij) is the hopping parameter from band i to band j. The on-site, nearest neighbour, next-to-nearest neighbour... hopping matrices are concatenated horizontally. The diagonal terms of the on-site matrix determine the filling.\nu: Btimes nB matrix in which element (ij) is the Coulomb repulsion U_ij=U_iijj between band i and band j. The on-site, nearest neighbour, next-to-nearest neighbour... matrices are concatenated horizontally.\nJ: Btimes nB matrix in which element (ij) is the exchange J_ij=U_ijji=U_ijij between band i and band j. The on-site, nearest neighbour, next-to-nearest neighbour... matrices are concatenated horizontally. The diagonal terms of the on-site matrix are ignored.\nU13: Btimes B matrix in which element (ij) is the parameter U_ijjj=U_jijj=U_jjij=U_jjji between band i and band j. Only on-site. The diagonal terms of the on-site matrix are ignored. This argument is optional.\nsvalue: The Schmidt truncation value, used to truncate in the iDMRG2 algorithm for the computation of the groundstate.\nbond_dim: The maximal bond dimension used to initialize the state.\n\nSpin-dependent calculations are not yet implemented.\n\nU13 inter-site, Uijkk, and Uijkl can be inserted using kwargs.\n\nUse the optional argument name to assign a name to the model.  This is used to destinguish between different parameter sets: Wrong results could be loaded or overwritten if not used consistently!!!\n\n\n\n\n\n","category":"type"},{"location":"Functions/#HubbardTN.MB_Sim","page":"Library","title":"HubbardTN.MB_Sim","text":"MB_Sim(t::Matrix{Float64}, u::Matrix{Float64}, J::Matrix{Float64}, U13::Matrix{Float64}, P=1, Q=1, svalue=2.0, bond_dim=50; kwargs...)\n\nConstruct a parameter set for a 1D B-band Hubbard model with a fixed number of particles.\n\nArguments\n\nt: Bx(nB) matrix in which element (ij) is the hopping parameter from band i to band j. The on-site, nearest neighbour, next-to-nearest neighbour... hopping matrices are concatenated horizontally.\nu: Bx(nB) matrix in which element (ij) is the Coulomb repulsion U_ij=U_iijj between band i and band j. The on-site, nearest neighbour, next-to-nearest neighbour... matrices are concatenated horizontally.\nJ: Bx(nB) matrix in which element (ij) is the exchange J_ij=U_ijji=U_ijij between band i and band j. The on-site, nearest neighbour, next-to-nearest neighbour... matrices are concatenated horizontally. The diagonal terms of the on-site matrix are ignored.\nU13: BxB matrix in which element (ij) is the parameter U_ijjj=U_jijj=U_jjij=U_jjji between band i and band j. Only on-site. The diagonal terms of the on-site matrix are ignored. This argument is optional.\nP,Q: The ratio P/Q defines the number of electrons per site, which should be larger than 0 and smaller than 2.\nsvalue: The Schmidt truncation value, used to truncate in the iDMRG2 algorithm for the computation of the groundstate.\nbond_dim: The maximal bond dimension used to initialize the state.\n\nPut the optional argument 'spin=true' to perform spin-dependent calculations. \n\nU13 inter-site, Uijkk, and Uijkl can be inserted using kwargs.\n\nUse the optional argument name to assign a name to the model.  This is used to destinguish between different parameter sets: Wrong results could be loaded or overwritten if not used consistently!!!\n\n\n\n\n\n","category":"type"},{"location":"Functions/#HubbardTN.OBC_Sim","page":"Library","title":"HubbardTN.OBC_Sim","text":"OBC_Sim(t::Vector{Float64}, u::Vector{Float64}, μf::Float64, svalue=2.0, bond_dim=50, period=0; mu=true, kwargs...)\n\nConstruct a parameter set for a 1D one-band Hubbard model with the number of particles determined by a chemical potential.\n\nArguments\n\nt: Vector in which element n is the value of the hopping parameter of distance n. The first element is the nearest-neighbour hopping.\nu: Vector in which element n is the value of the Coulomb interaction with site at distance n-1. The first element is the on-site interaction.\nµf: The chemical potential, if mu=true. Otherwise, the filling of the system. The chemical potential corresponding to the given filling is determined automatically.\nsvalue: The Schmidt truncation value, used to truncate in the iDMRG2 algorithm for the computation of the groundstate.\nbond_dim: The maximal bond dimension used to initialize the state.\nPeriod: Perform simulations on a helix with circumference Period. Value 0 corresponds to an infinite chain.\n\nSpin-dependent calculations are not yet implemented.\n\n\n\n\n\n","category":"type"},{"location":"Functions/#HubbardTN.OB_Sim","page":"Library","title":"HubbardTN.OB_Sim","text":"OB_Sim(t::Vector{Float64}, u::Vector{Float64}, μ=0.0, J::Vector{Float64}=[0.0], P=1, Q=1, svalue=2.0, bond_dim=50, period=0; kwargs...)\n\nConstruct a parameter set for a 1D one-band Hubbard model with a fixed number of particles.\n\nArguments\n\nt: Vector in which element n is the value of the hopping parameter of distance n. The first element is the nearest-neighbour hopping.\nu: Vector in which element n is the value of the Coulomb interaction with site at distance n-1. The first element is the on-site interaction.\nJ: Vector in which element n is the value of the exchange interaction with site at distance n. The first element is the nearest-neighbour exchange.\nµ: The chemical potential.\nP,Q: The ratio P/Q defines the number of electrons per site, which should be larger than 0 and smaller than 2.\nsvalue: The Schmidt truncation value, used to truncate in the iDMRG2 algorithm for the computation of the groundstate.\nbond_dim: The maximal bond dimension used to initialize the state.\nPeriod: Perform simulations on a helix with circumference Period. Value 0 corresponds to an infinite chain.\n\nPut the optional argument spin=true to perform spin-dependent calculations.\n\n\n\n\n\n","category":"type"},{"location":"Functions/#HubbardTN.calc_ms-Tuple{Union{MB_Sim, OB_Sim}}","page":"Library","title":"HubbardTN.calc_ms","text":"calc_ms(model::Union{OB_Sim,MB_Sim})\n\nCompute the staggered magnetization of the ground state.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.density_spin-Tuple{Union{MB_Sim, OB_Sim}}","page":"Library","title":"HubbardTN.density_spin","text":"density_spin(model::Union{OB_Sim,MB_Sim}; path::String=\"\")\n\nCompute the density of spin up and spin down per site in the unit cell for the ground state stored at path.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.density_state-Tuple{Union{MB_Sim, OB_Sim}}","page":"Library","title":"HubbardTN.density_state","text":"density_state(model::Simulation; path::String=\"\")\n\nCompute the number of electrons per site in the unit cell for the ground state stored at path.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.dim_state-Tuple{MPSKit.InfiniteMPS}","page":"Library","title":"HubbardTN.dim_state","text":"dim_state(ψ::InfiniteMPS)\n\nDetermine the bond dimensions in an infinite MPS.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.extract_params-Tuple{String}","page":"Library","title":"HubbardTN.extract_params","text":"extract_params(path::String; range_u::Int64= 1, range_t::Int64=2, range_J::Int64=1, \n                    range_U13::Int64=1, r_1111::Int64 = 1, r_112::Int64 = 1)\n\nExtract the parameters from a params.jl file located at path in PyFoldHub format.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.load_state-Tuple{String}","page":"Library","title":"HubbardTN.load_state","text":"load_state(path::String) -> InfiniteMPS\n\nLoad an InfiniteMPS object from a directory of saved .jld2 tensor files.\n\nArguments\n\npath::String: Path to the directory containing the saved MPS tensor files  (e.g., state1.jld2, state2.jld2, ...).\n\nDescription\n\nThis function reconstructs an InfiniteMPS object previously saved with save_state.   It reads all .jld2 files in the specified directory, converts each stored Dict back into a TensorMap, and combines them into a periodic array before wrapping  the result in an InfiniteMPS object.\n\nReturns\n\nInfiniteMPS: The reconstructed infinite matrix product state.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.plot_excitations-Tuple{Any, Any}","page":"Library","title":"HubbardTN.plot_excitations","text":"plot_excitations(momenta, energies; title=\"Excitation_energies\", l_margin=[15mm 0mm])\n\nPlot the obtained energy levels in functions of the momentum.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.plot_spin-Tuple{HubbardTN.Simulation}","page":"Library","title":"HubbardTN.plot_spin","text":"plot_spin(model::Simulation; title=\"Spin Density\", l_margin=[15mm 0mm])\n\nPlot the spin density of the model throughout the unit cell as a heatmap.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.produce_TruncState-Tuple{HubbardTN.Simulation, Int64}","page":"Library","title":"HubbardTN.produce_TruncState","text":"produce_truncstate(model::Simulation, trunc_dim::Int64; trunc_scheme::Int64=0, force::Bool=false, path::String=\"\", path_gs::String=path)\n\nCompute or load a truncated approximation of the groundstate.\n\nArguments\n\nmodel: Model for which the groundstate is to be truncated.\ntrunc_dim: Maximal bond dimension of the truncated state.\ntrunc_scheme: Scheme to perform the truncation. 0 = VUMPSSvdCut. 1 = SvdCut.\nforce: If true, overwrite existing calculation.\npath: Path to save/load the calculation.\npath_gs: Path to load the groundstate from, if different from path.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.produce_bandgap-Tuple{Union{MB_Sim, OB_Sim}}","page":"Library","title":"HubbardTN.produce_bandgap","text":"produce_bandgap(model::Union{OB_Sim, MB_Sim}; resolution::Int64=5, force::Bool=false)\n\nCompute or load the band gap of the desired model.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.produce_excitations-Tuple{HubbardTN.Simulation, Any, Int64}","page":"Library","title":"HubbardTN.produce_excitations","text":"produce_excitations(model::Simulation, momenta, nums::Int64; path::String=\"\", path_gs::String=path, force::Bool=false, charges::Vector{Float64}=[0,0.0,0], kwargs...)\n\nCompute or load quasiparticle excitations of the desired model.\n\nArguments\n\nmodel: Model for which excitations are sought.\nmomenta: Momenta of the quasiparticle excitations.\nnums: Number of excitations.\npath: Path to save/load the calculation.\npath_gs: Path to load the groundstate from, if different from path.\nforce: If true, overwrite existing calculation.\ncharges: Charges of the symmetry sector of the excitations.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.produce_groundstate-Tuple{Union{MBC_Sim, MB_Sim}}","page":"Library","title":"HubbardTN.produce_groundstate","text":"produce_groundstate(model::Simulation; force::Bool=false, path=\"\")\n\nCompute or load groundstate of the model. If force=true, overwrite existing calculation.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#HubbardTN.save_state-Tuple{MPSKit.InfiniteMPS, String, String}","page":"Library","title":"HubbardTN.save_state","text":"save_state(ψ::InfiniteMPS, path::String, name::String)\n\nSave the tensors of an InfiniteMPS object to disk as individual .jld2 files.\n\nArguments\n\nψ::InfiniteMPS: The infinite matrix product state (MPS) whose tensors will be saved.\npath::String: The base directory where the state folder will be created.\nname::String: The name of the subdirectory under path where the tensors will be stored.\n\nDescription\n\nThis function creates a subdirectory joinpath(path, name) and saves each tensor  ψ.AL[i] as a .jld2 file named state<i>.jld2 inside it. Each tensor is converted  to a Dict before saving for serialization compatibility. The function prints  a message after each tensor is successfully saved.\n\n\n\n\n\n","category":"method"},{"location":"#HubbardTN","page":"Home","title":"HubbardTN","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for HubbardTN, a tool for implementing and solving general 1D multi-band Hubbard models using tensor networks. The framework is built upon the packages MPSKit.jl and TensorKit.jl. DrWatson.jl is used to automatically store your results in the desired location.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To add this package to your Julia environment, do","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"https://github.com/DaanVrancken/HubbardTN.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"after which it can be used by loading","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using HubbardTN","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The overall outline of the simulations is always the same. First, choose the type of Hubbard model that you are interested in. The different options are defined by their symmetries: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"One-band model\nSpin symmetry and conserved number of electrons, mathbbZ_2times SU(2)times U(1).\nConserved number of spin up and down electrons, mathbbZ_2times U(1)times U(1).\nSpin symmetry, mathbbZ_2times SU(2).\nMulti-band model\nSpin symmetry and conserved number of electrons, mathbbZ_2times SU(2)times U(1).\nConserved number of spin up and down electrons, mathbbZ_2times U(1)times U(1).\nSpin symmetry, mathbbZ_2times SU(2).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Proceed by inserting the parameters of the model. You are now ready to compute the ground and excited states and their properties!","category":"page"}]
}
